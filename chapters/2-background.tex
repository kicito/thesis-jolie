\chapter{Background}

\section{Jolie Programming Language}

\textbf{Jolie}\cite{JOLIE} is a general purpose programming language.
It is the first service-oriented programming language such that each of a a single Jolie program can be deployed independently as a service.
The goal of Jolie is to bring the formalized model of a service and composition calculus \textbf{SOCK} \cite{10.1007/11948148-27} and the practical workflow language WS-BPEL\cite{OASIS}.
For the syntax of language, Jolie use a block structured programming syntax similar to C and Java combined with effort to make the language simple and straightforward; as a result, learning curve for Jolie is flat for those who are already familiar with coding.

In this section, we briefly explain the Jolie program structure and it's components that are involved in Jolie module system. For those who keen to know more about advance topics in Jolie are recommended to visit \cite{joliedoc, JOLIE}.

Jolie program, or a service, is a file containing Jolie definitions which consists of three types of components, namely, the definitions, the service deployment description, and the service behavior.

Jolie definition declarations represent type structure definition and interface for a service.

A deployment description defines the communication layer of the service, such as protocol, location and the operation name accepted by a communication ports.

The detail of a service workflow is defined in service behavior part. The communication and computation instructions are composed together to a complex executable workflow which later will be execute at runtime.

Figure ~\ref{fig:JolieGrammar} demonstrate a syntax of Jolie program.

\begin{figure}[h]
    \begin{framed}
        \begin{grammar}
            <jolie> ::= <includeStmt>* <definition>* <deplInstruction>*  `main' `{' <behaviors> `}'
        \end{grammar}
    \end{framed}
    \caption{Jolie Program Syntax}
    \label{fig:JolieGrammar}
\end{figure}

\FloatBarrier

\subsection{Definition declaration}
\label{sec:jolie-def}

The definition declaration is a set of an information related to a service. The interface definition encapsulate operations into a group, which it is referred during defining a communication protocol. Each of the operation in Jolie is defined by a name and a message structure, or a type, required for passing and receiving. While the procedure definition groups instructions composition to be call in runtime execution. These declarations are used in the service itself, or can be defined in an external file and retrieved using include statement which is presented in section ~\ref{sec:jolie-include}.

\input{chapters/background/jolie/jolie-typeDefinition}

\input{chapters/background/jolie/jolie-interfaceDefinition}

\input{chapters/background/jolie/jolie-procedureDefinition}

We can revisit the syntax of the \(<definition>\) rules as it can be represented by three components which are types, interfaces, and procedures as shown in figure ~\ref{fig:jolie-definition}

\begin{figure}[h]
    \begin{framed}
        \begin{grammar}
            <definition> ::= <typeDefinition>
            \alt <interfaceDeclaration>
            \alt <procedureDefinition>
        \end{grammar}
    \end{framed}
    \caption{Jolie Grammar for definition part}
    \label{fig:jolie-definition}
\end{figure}

\subsection{Deployment description}

Deployment description expresses the relation between services, whether it is a producer, consumer, or mediator of the interface.
These description is defined in a port which encapsulate details of communication specification in the system.
Jolie also provide a primitive to declare a dependency of the service, through embedding statement, which help Jolie programmer composing a complex service with ease.

\input{chapters/background/jolie/jolie-portDeclaration}

\input{chapters/background/jolie/jolie-executionMode}

\input{chapters/background/jolie/jolie-embedding}


As before, we can now defines a syntax for the \(<deplInstruction>\) as following

\begin{figure}[h]
    \begin{framed}
        \begin{grammar}
            <deplInstruction> ::= <executionMode>
            \alt <outputPort>
            \alt <inputPort>
            \alt <embedStmt>
            \alt <internalService>
        \end{grammar}
    \end{framed}
    \caption{Jolie Grammar for deployment instruction part}
    \label{fig:jolie-depl}
\end{figure}


\subsection{Behavior declaration}
\label{sec:jolie-behavior}

The behaviors in Jolie define a composition of tasks, so called a processes, which is invoked when the service receive a message matching the exposed operation or when it is performing a sequential program. A process is essentially a program statement in other programming language, but as it is built from a distributed system concept, Jolie processes are composing in different way. Composing processes, as shown in the syntax rule \(<continuation>\) in figure ~\ref{fig:jolie-process}  uses semicolon \((;)\) to define a sequential statement and pipe \((|)\) for a parallel statement. For example given two statement \(A\) and \(B\) if we write \(A ; B\) Jolie interprets it as \textit{`execute A then B"} while \(A | B\) as \textit{`concurrently execute A and B"}. If the continuation is not defined, the default value is a sequential composition \((;)\).

In addition to the support of basic statements as other programming languages, Jolie natively supports a communication statements, which consist of two patterns, i.e. One-Way operation and Request-Response operation. As the name suggested, One-Way operation send a message through port and continue, while Request-Response waits for a response message from the target port then continue. With these concepts, a Jolie program encapsulate a whole communication procedure within a single statement. From the syntax, the \(<operationName>\), \(<outputPortName>\) are an identifier referring to the calling operation and port name respectively, while \(expr\) is an basic expression that is use to send and storing the received data.

Another service-oriented statement supported by Jolie is an Nondeterministic Choice defined in \(<ndInputChoices>\), which determine a workflow of the service, when the accepted operation get called. It is useful when a service is acting as provider in the system. The workflow consist of two parts of execution definition defined in \(<processes>\) syntax rule. Firstly, defined within square brackets scope, normally used for building an response for return to client since it is executing upon the operation is invoked. The second one, defined after the brackets, is performed after service has responded to the client, it useful in a situation where there are blocking tasks that do not contributed to the response message.

\begin{figure}[h]
    \begin{framed}
        \begin{grammar}
            <processes>
            ::= <process> ( continuation? <process> )*

            <continuation> ::= `|' \hfill (parallel composition)
            \alt `;' \hfill (sequential composition)

            <process> ::= \dots
            \alt <ndInputChoices> \hfill (non-deterministic Choice)
            \alt <inputStmt> \hfill (input operation statement)
            \alt <outputStmt> \hfill (output operation statement)

            <ndInputChoices>
            ::= <ndInputChoice>+

            <ndInputChoice>
            ::= '[' <inputStmt> `{' <processes> `}' ? ']' <processes>?

            <inputStmt>
            ::= <operationName> '(' <expr>? ')' \hfill (one-way)
            \alt
            <operationName> '(' <expr>? ')' '(' <expr>? ')' ( `{' <processes> `}' )? \hfill (request-response)

            <outputStmt>
            ::= <operationName> `@' <outputPortName> '(' <expr>? ')' \hfill (one-way)
            \alt
            <operationName> `@' <outputPortName> '(' <expr>? ')' '(' <expr>? ')' \hfill (request-response)
        \end{grammar}
    \end{framed}
    \caption{Jolie Grammar for deployment instruction part}
    \label{fig:jolie-process}
\end{figure}

Now lets look back to the Jolie service in example ~\ref{list:example-port}, at line 15-18

\begin{lstlisting}{ndChoice}
    createPerson(person)(result){
        log@LoggerOutputPort(person)
        result = true
    }
\end{lstlisting}
The statement \texttt{createPerson(person)(result)} tells the runtime execution to wait for a receiving operation \texttt{createPerson} and assign the receiving message to \texttt{person} variable then an execution proceed with the processes defined in brace scope. After the execution in the brace finished, the value in variable \texttt{result} will be sent back to the operation caller.


\FloatBarrier

\input{chapters/background/jolie/jolie-include}

\input{chapters/background/jolie/jolie-interpreter}


\section{Module System}

Module system is a system consisting of composition of an independent executable program unit. A program unit contains every definition and functionality intended to solve one specific problem, each program unit is called Modules in the module system. Each module can be parsed into a module interface, which defines a name of public symbols and the required symbols from other modules. The module interface allows other modules access providing symbols and use its implementation details in their environment. The Module System targets the decomposition of large applications into smaller pieces. This led the developer of the supported module system programming language to reuse their codes and allow the concept of package managing tools, which helps engage its community to collaborate more and grow faster.

Import statement is the statement that is commonly used in the Modular programming language to access and retrieve definitions between modules. It is generally responsible for locating the target module, and resolve the definition to the local execution environment.

Usage of terms in the Module system varies between programming languages as their implementation detail of the module system. Before diving into the module's system of each selected popular programming language, the reader will be introduced with the term that is used within their context.

We had review the following programming languages such as

In the sections below, we mainly focus on Python programming language, since it's rich of documentation wise on it's history and their design choice available and it inspired our implementation of Jolie's module system.

\input{chapters/background/module-system/module-python.tex}

\chapter{Jolie Module System}

In this chapter, we present the module system for Jolie.
Similarly to how we presented the Python module system, we will walkthrough the definitions, components, import mechanism, and lastly, the redesign of Jolie's code file layout.

\section{Definitions}

Before delving into the details, it is crucial to have a clear definition of terms used in the Jolie module system. In Jolie:

\begin{itemize}
      \item
            A \textbf{symbol} is a declaration of a file-level abstract node definition. The symbol target is defined along with a module target in the import statement, to specify an imported named definition node.
      \item
            A \textbf{module} is defined as a Jolie program in the file system. A module is a file that contains symbols and the execution target for running the Jolie code.
      \item
            A \textbf{package} is defined as either a directory in the file system or a file. A package role in the Jolie module system is a place to hold the modules and can be part of the module target. A file with \texttt{.jap} extension, the Jolie's JAR-like archive file is considered as a package which it's entry can be referred to as a module.
      \item
            A \texttt{script} is a module which includes a service definition named \texttt{main}. A script can be used as an execution target by the Jolie interpreter. 
\end{itemize}

\input{chapters/modulesystem/importstmt}
\input{chapters/modulesystem/symbol-and-symboltable}
\input{chapters/modulesystem/name-resolution}
\input{chapters/modulesystem/module-crawling}
\input{chapters/modulesystem/implementation}

\input{chapters/modulesystem/servicenode}
\input{chapters/modulesystem/code-example}



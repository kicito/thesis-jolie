\chapter{Jolie Module System}

In this chapter, we present the module system for Jolie.
Similarly to how we presented the Python module system, we will walk-though the definitions, components, import mechanism, and lastly, the redesign of Jolie's code file layout.

\section{Definitions}

Before diving into the details, defining a definition of components in a module system is beneficial since the keyword has been using differently from programming languages. In Jolie:

\begin{itemize}
      \item
            A \textbf{symbol} is a declaration of a file-level abstract node definition. The symbol target is defined along with a module target in the import statement, to specify an imported named definition node.
      \item
            A \textbf{module} is defined as a Jolie program in the file system. A module is a file that contains symbols and the execution target for running the Jolie code.
      \item
            A \textbf{package} is defined as either a directory in the file system or a file. A package role in the Jolie module system is a place to hold the modules and can be part of the module target. A file with \texttt{.jap} extension, the Jolie's JAR-like achieve is considered as a package which it's entry can be referred to as a module.
      \item
            A \texttt{script} is an module which included a service definition named \texttt{main}. A script can be used as an execution target by the Jolie interpreter. 
\end{itemize}

\input{chapters/modulesystem/importstmt}
\input{chapters/modulesystem/symbol-and-symboltable}
\input{chapters/modulesystem/name-resolution}
\input{chapters/modulesystem/module-crawling}
\input{chapters/modulesystem/implementation}

\input{chapters/modulesystem/servicenode}
\input{chapters/modulesystem/code-example}



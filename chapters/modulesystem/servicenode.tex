\section{Service Node}

As the adjustment of Jolie execution file definition has changed, the file structure layout has to be modified as well.  At top level definitions, the abstract syntax of definition nodes such as types and interfaces are remained. But the service related syntax nodes such as behavioral and instruction on deployment has to be moved into a proper scope which represent a definition of a service. This lead to an introduction of a new syntax node in Jolie module system; such node is called a \textit{Service Node}.

In the implementation level, Service Node is responsible for storing deployment instructions and behaviors of a service. It may optionally accepted a parameter, which can be passed to during embedding process.
With this change, we can use the import mechanism to import and embed a service easily, by specify a service as an identifier, rather than using string defining a path as before.
The definition of service node also covers declaration of the external technology service, in particular, the one that we used in existed embedding mechanism ~\ref{sec:embedded}.
In this new implementation of foreign technology service node, it can be view as a special type of jolie service which can interact with foreign technology.
The grammar for Jolie module system is defined in figure ~\ref{fig:jolie-servicenode-grammar}

\begin{figure}[h]
    \begin{framed}
        \begin{grammar}
            <jolie> ::= <importStmt>* <definitions>*

            <definitions> ::= `private'? <definition>

            <definition> ::=  <typeDefinition>
            \dots
            \alt <serviceNode>

            <serviceNode> ::= `service' <technology>? <ID> <param>? \\ `{' <deplInstruction>* `main' `{' <behaviors> `}'`}'

            <technology> ::= <java> | <javascript> | <jolie>

            <jolie> ::= `Jolie'

            <java> ::= `Java' `(' <StringLiteral> `)'

            <javascript> ::= `Javascript' `(' <StringLiteral> `)'

            <param> ::= `(' <ID> : <paramType> `)'

            <paramType> ::= <ID>
        \end{grammar}
    \end{framed}
    \caption{Jolie Service Node Grammar}
    \label{fig:jolie-servicenode-grammar}
\end{figure}

\begin{listing}[h]

    \lstset{language=Jolie,
        style=codeStyle,
        numbers=left,
        firstnumber=1
    }
    \begin{lstlisting}[frame=tlrb, caption= {Jolie Service Node Example}, label={list:jolie-servicenode} ]{servicenode-jolie}
interface prefixerIface{
    requestResponse: prefix(string)(string)
}

service prefixService ( prefix: string )  {
    
    inputPort IP {
        interfaces : prefixerIface
        protocol: sodep
        location : "socket://localhost:3000"
    }

    execution{ concurrent }

    main {
        [prefix(req)(res){
            res = prefix + req
        }]
    }
}
    \end{lstlisting}
\end{listing}

Listing ~\ref{list:jolie-servicenode} illustrates a code snippet for declaration of service node, \textit{prefixService}. The service accept a string as a parameter 

It is in clear view that the definitions that direct the behavior of a service is encapsulate in a Service Node called \textit{mulService}, This service accepted a value of integer, which determine a second factor of multiplication operation. It is also exposes the communication channel through an interface \textit{mulIface}, which is declared at file level scope and can be imported by an external module.

\FloatBarrier

\subsubsection*{Jolie Script}

Running a Jolie interpreter instance involve a translation of a service abstraction into an OOIT as one of the execution process.
As we have changed the definition of a service, in particular, a Jolie executable file is no longer represent a service, rather becoming a module.   
We also introduce an encapsulation of the service abstraction into a service node, which multiple can be defined within a single module.
For these reasons, making it ambiguous for an interpreter to decided which service node to be used as an translation target, it is essential to have a convention of target service node when a module is given as a execution target.
Hereby, we introduce the definition of an executable Jolie module so called \textit{Jolie script}.

Jolie script, a main candidate for running Jolie program, is a module that included a service node named \texttt{main}. Considering the listing ~\ref{list:jolie-procedure-script} which is a rewritten version of the example we had before in ~\ref{list:procedure}, the only difference here is the behavior of the service is enclosed in a special service node named main. Which is a execution target when the script get pass to the command-line.

It is worth mentioning that running a non Jolie script modules, similar to running a Jolie program without a main procedure, is prohibited and program will terminate during semantic verifying step.

\begin{listing}[h]
    \lstset{language=Jolie,
        style=codeStyle
    }
\begin{lstlisting}[frame=tlrb, caption= {A Jolie script version of ~\ref{list:procedure}}, label={list:jolie-procedure-script}]{procedure-script-Jolie}
define doubleX{
    X = X * 2
}

service main {
    X = 5
    doubleX
    // now X == 10
}
\end{lstlisting}
\end{listing}

\subsection{Embedding Service Node}

As the definition of service has changed, we also needed to take a careful look at the embedding mechanism for supporting a service node. As per a distinct syntax between current Jolie implementation where it defined the embedding node through a string literal to service path in file system. We separated a new statement, so-called \textit{embed}, for the declaration of embedding a service node. The syntax for declaring an embed statement is shown in figure ~\ref{fig:jolie-servicenode-embed-grammar}.

            % embed someservice2(ConstLiteral) in new OP2

\begin{figure}[h]
    \begin{framed}
        \begin{grammar}
            <deplInstruction> ::= ... 
            \alt <embedStmt>

            <embedStmt> ::= `embed' <serviceName> <args>? <bindingPort>?  

            <args> ::= `(' <expr> `)'

            <serviceName> ::= <ID>

            <bindingPort> ::= `in' `new'? <portID>

            <portID> ::= <ID>

        \end{grammar}
    \end{framed}
    \caption{Embedding service node grammar}
    \label{fig:jolie-servicenode-embed-grammar}
\end{figure}

The declaration of the new embedding statement for a service node can be declared in three ways, depending on the need of binding a port between the embedder and the embedded service. The jolie developer can explicitly define a behavior of the embedding through a straightforward syntax similar to the original one. 

In order to understand the implementation of the embedding service node. Firstly, the embedding a service required passing a value that is a type declared in the embedder's parameter. if the value is omitted, the interpreter will pass a value of \textit{undefined} to a service node. If the value has a valid structure as defined constrain in the target embedding node. Following cases are consider:

\begin{itemize}
    \item if the binding port is not defined, the embedding service is initiate as a standalone service that doesn't has any binding communication channel between embedded and embedding service.
    \item if the binding port is defined using an existed port, the embedding service is initiated with bounded communication channel between it's incoming port declared using local memory and the binding port in the embedder.
    \item if the binding port is defined using \textit{new} keyword, the embedding service is initiated with bounded communication channel between it's incoming port declared using local memory and the newly created outgoing port in the embedder.
\end{itemize}

The evolution of embedding mechanism statement, by using a symbol referring to a service instead a string path, also helps Jolie's interpreter eliminates an error that might occur during resolving a target service path which was checking during runtime of the execution. As the abstraction node is resolved during name resolution step, this error is caught preemptively during before runtime execution. Moreover, it also helps generalizing path resolution algorithm for Jolie internal statements into one place, namely through the import statement.

\subsubsection{Parameterize Service}

A service node of Jolie is parameterize. 

\subsection{Backward compatibility}

Since Jolie module system is relatively new and cause a breaking change on the previous version, we decided to keep the backward compatible with the old syntax. If the interpreter detected old syntax or jolie file, the AST will be transform by moving all behavior and deployment instruction nodes into the newly created main Service Node while definition nodes will remain in top level definitions. The method of detecting old syntax is relatively easy, one of trivial method is to detect whether the AST contain an Procedure Definition named \texttt{main}.

\begin{algorithm}[h]
    \caption{TransformJolieCodeToModule}
    \label{algo:transfrom}
    \begin{algorithmic}[1]
        \Require{An abstract syntax tree of Jolie program $program$}
        \Ensure {An abstract syntax tree of Jolie Module $result$}

        \Procedure {transform}{}
        \State $moduleProgram\gets$ new list\Comment{new module's program node}
        \State $serviceProgram\gets$ new list\Comment{new new Service program node}

        \ForAll{$node$ in $program$}
        \If{$node$ is $Symbol$}
        \If{$node$ is $Procedure$ and $node$ named \texttt{`main"} or \texttt{`init"} }
        \State \Call{$serviceProgram.add$}{$node$}
        \Else
        \State \Call{$moduleProgram.add$}{$node$}
        \EndIf
        \Else{
            \If{$node$ is $ImportStatement$}
            \State \Call{$moduleProgram.add$}{$node$}
            \Else
            \State \Call{$serviceProgram.add$}{$node$}
            \EndIf
        }
        \EndIf
        \EndFor
        \State $serviceNode \gets$ new service node from $serviceProgram$
        \State \Call{$moduleProgram.add$}{$serviceNode$}
        \State $result \gets$ $moduleProgram$
        \EndProcedure

    \end{algorithmic}
\end{algorithm}
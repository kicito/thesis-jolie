\section{Service Node}

As the adjustment of Jolie execution file definition has changed, the file structure layout has to be modified as well.  At top level definitions, the abstract syntax of definition nodes such as types and interfaces remain. But the service-related syntax nodes such as behavioral and instruction on deployment have to be moved into a proper scope that represents a service definition. This leads to an introduction of a new syntax node in the Jolie module system; such a node is called a \textit{Service Node}.

At the implementation level, the service node is responsible for storing deployment instructions and behaviors of a service. It may optionally accept a parameter, which can be passed to during the embedding process.
The definition of service node also covers the declaration of the external technology service, particularly the one that we used in the existing embedding mechanism ~\ref{sec:embedded}.
In this new implementation of the foreign technology service node, it can be viewed as a special type of Jolie service that can interact with supported external technology, such as Java.
The grammar for Jolie module system is defined in figure ~\ref{fig:jolie-servicenode-grammar}

\begin{figure}[h]
    \begin{framed}
        \begin{grammar}
            <jolie> ::= <importStmt>* <definitions>*

            <definitions> ::= <accessMod>? <definition>

            <accessMod> ::= `private' | `public'

            <definition> ::=  <typeDefinition>
            \dots
            \alt <serviceNode>

            <serviceNode> ::= `service' <technology>? <ID> <param>? \\ `{' <deplInstruction>* `main' `{' <behaviors> `}'`}'

            <technology> ::= <java> | <javascript> | <jolie>

            <jolie> ::= `Jolie'

            <java> ::= `Java' `(' <StringLiteral> `)'

            <javascript> ::= `Javascript' `(' <StringLiteral> `)'

            <param> ::= `(' <ID> `:' <paramType> `)'

            <paramType> ::= <ID>
        \end{grammar}
    \end{framed}
    \caption{Jolie Service Node Grammar}
    \label{fig:jolie-servicenode-grammar}
\end{figure}

\begin{listing}[h]

    \lstset{language=Jolie,
        style=codeStyle,
        numbers=left,
        firstnumber=1
    }
    \begin{lstlisting}[frame=tlrb, caption= {Jolie Service Node Example}, label={list:jolie-servicenode} ]{servicenode-jolie}
interface prefixerIface{
    requestResponse: prefix(string)(string)
}

service prefixService {
    
    inputPort IP {
        interfaces : prefixerIface
        protocol: sodep
        location : "socket://localhost:3000"
    }

    execution{ concurrent }

    main {
        [prefix(req)(res){
            res = "PREFIXED: " + req
        }]
    }
}
    \end{lstlisting}
\end{listing}

Listing ~\ref{list:jolie-servicenode} illustrates a code snippet for service node declaration, \textit{prefixService}. The service exposes one operation, \textit{prefix}, which returns a prefixed string. The prefixed string is defined within the operation in this example; we will see how we can be configured later in this section.

\FloatBarrier

\subsubsection*{Jolie Script}

As we have changed the definition of a service, in particular, a Jolie executable file is no longer represents a service, instead of becoming a module that may contain multiple declarations of the service node. It is necessary to define how an interpreter interprets this service abstractions into the execution processes for executing a Jolie interpreter instance.
It is essential to have a concrete specification of a target service node when a module is given as an execution target.
With this, we introduce the definition of an executable Jolie module so-called \textit{Jolie script}.
Jolie script is a module that included a service node named \texttt{main}, which is a target of OOIT process translation when the interpreter is executing a Jolie module. Considering the listing ~\ref{list:jolie-procedure-script}, which is a rewritten version of the example we had before in ~\ref{list:procedure}, the only difference here is the behavior of the service is enclosed in a service node named main. 

It is worth mentioning that a non-Jolie script module is considered a Jolie program without a main procedure. An attempt to execute this will raised and error since the interpreter will not be able to specify the target execution service.

\begin{listing}[h]
    \lstset{language=Jolie,
        style=codeStyle
    }
    \begin{lstlisting}[frame=tlrb, caption= {A Jolie script version of ~\ref{list:procedure}}, label={list:jolie-procedure-script}]{procedure-script-Jolie}


service main {
    define doubleX{
        X = X * 2
    }

    main{
        X = 5
        doubleX
        // now X == 10
    }
}
\end{lstlisting}
\end{listing}

\subsection{Embedding Mechanism of Service Node}

As the definition of service has changed, we also took a careful examination at the embedding mechanism for supporting a service node.
From the current implementation of the embed statement where the specifier is a string literal to a path of the service and the binding communication port, which is not compatible with the symbol identifier that we have introduced, we separated a new primitive called \textit{embed}, for the declaration of embedding a service node.
The syntax for declaring an embed statement is shown in figure ~\ref{fig:jolie-servicenode-embed-grammar}.

% embed someservice2(ConstLiteral) in new OP2

\begin{figure}[h]
    \begin{framed}
        \begin{grammar}
            <deplInstruction> ::= ...
            \alt <embedStmt>

            <embedStmt> ::= `embed' <serviceName> <args>? <bindingPort>?

            <args> ::= `(' <expr> `)'

            <serviceName> ::= <ID>

            <bindingPort> ::= `in' `new'? <portID>

            <portID> ::= <ID>

        \end{grammar}
    \end{framed}
    \caption{Embedding service node grammar}
    \label{fig:jolie-servicenode-embed-grammar}
\end{figure}

The declaration of the new embedding statement for a service node can be declared in three ways, depending on the need of binding a port between the embedder and the embedded service. The jolie developer can explicitly define a behavior of the embedding through a straightforward syntax similar to the original one.

In order to understand the implementation of the embedding service node. Firstly, the embedding a service required passing a value that is a type declared in the embedder's parameter. if the value is omitted, the interpreter will pass a value of \textit{undefined} to a service node. If the value has a valid structure as defined constrain in the target embedding node. Following cases are consider:

\begin{itemize}
    \item if the binding port is not defined, the embedding service is initiate as a standalone service that doesn't has any binding communication channel between embedded and embedding service.
    \item if the binding port is defined using an existed port, the embedding service is initiated with bounded communication channel between it's incoming port declared using local memory and the binding port in the embedder.
    \item if the binding port is defined using \textit{new} keyword, the embedding service is initiated with bounded communication channel between it's incoming port declared using local memory and the newly created outgoing port in the embedder.
\end{itemize}

The evolution of embedding mechanism statement, by using a symbol referring to a service instead a string path, also helps Jolie's interpreter eliminates an error that might occur during resolving a target service path which was checking during runtime of the execution. As the abstraction node is resolved during name resolution step, this error is caught preemptively during before runtime execution. Moreover, it also helps generalizing path resolution algorithm for Jolie internal statements into one place, namely through the import statement.

\subsubsection{Parameterize Service}

A service node can be parameterize by passing a value through embedding statement. The value of which applied to an identifier and can be used as a variable within a service node scope. This feature allows service developer to exposed certain configuration of the deployment instructions and give the authority to the embedder freedom to configured.

We are taking a look back at the service node syntax. The syntax of parameter declaration consisted of the path of a variable assigned from the embedder. Follow by a reference to the accepted type value structure.

\[
    \text{service $<$\textit{name}$>$ $($ $<$\textit{variablePath}$>$ $:$ $<$\textit{paramType}$>$ $)$}
\]

The communication port configuration is also extended to accept an expression in \textit{protocol} and \textit{location}. This extension allows the possibility to configure communication more flexibly.

As shown in ~\ref{list:jolie-para-servicenode}, which is a parameterize version of ~\ref{list:jolie-servicenode}, an additional type definition \textit{prefixServiceParam} at the top-level express a parameter type for the service. It exposes three configurable values for the embedder to decide the prefix string and incoming communication channel detail. The communication port definition \textit{IP} in the service node is assigned to an expression value that directs to a path of the variable. This value is to be resolved during embedding the service.

\begin{listing}[h]

    \lstset{language=Jolie,
        style=codeStyle,
        numbers=left,
        firstnumber=1
    }
    \begin{lstlisting}[frame=tlrb, caption= {Jolie Parameterize Service Node Example}, label={list:jolie-para-servicenode} ]{servicenode-jolie}
interface prefixerIface{
    requestResponse: prefix(string)(string)
}

type prefixServiceParam : void{
    ip_loc : string
    ip_prot : string
    prefix : string
}

service prefixService (p: prefixServiceParam) {
    
    inputPort IP {
        interfaces : prefixerIface
        protocol: p.ip_prot
        location : p.ip_loc
    }

    execution{ concurrent }

    main {
        [prefix(req)(res){
            res = p.prefix + req
        }]
    }
}
    \end{lstlisting}
\end{listing}

\subsection{Backward compatibility}

Since the Jolie module system is relatively new and caused breaking changes, we decided to keep the backward compatibility with the old syntax. If the interpreter detected old syntax in the Jolie execution target, the AST would be transformed by moving all behavior and deployment instruction nodes into the newly created \textit{main} service node. In contrast, definition nodes will remain in top-level definitions. The method of detecting old syntax is relatively easy. One of the trivial techniques to identify whether the AST contains a procedure definition named \texttt{main} in the file declaration level if found; the respected service is written in the old version of Jolie. The algorithm for transforming a Jolie code is shown in algorithm ~\ref{algo:transfrom}

\begin{algorithm}[ht]
    \caption{TransformJolieCodeToModule}
    \label{algo:transfrom}
    \begin{algorithmic}[1]
        \Require{An abstract syntax tree of Jolie program $program$}
        \Ensure {An abstract syntax tree of Jolie Module $result$}

        \Procedure {transform}{}
        \State $moduleProgram\gets$ new list\Comment{new module's program node}
        \State $serviceProgram\gets$ new list\Comment{new new Service program node}

        \ForAll{$node$ in $program$}
        \If{$node$ is not $Symbol$ and $node$ is not $ImportStatement$ }
        \State \Call{$serviceProgram.add$}{$node$}
        \Else
        \State \Call{$moduleProgram.add$}{$node$}
        \EndIf
        \EndFor
        \State $serviceNode \gets$ new service node from $serviceProgram$
        \State \Call{$moduleProgram.add$}{$serviceNode$}
        \State $result \gets$ $moduleProgram$
        \EndProcedure

    \end{algorithmic}
\end{algorithm}

\FloatBarrier